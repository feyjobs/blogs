---
title: 现代操作系统
date: 2017-05-20 17:43:10
categories: 
- 阅读
- 现代操作系统
tags:
---
## 存储管理
>操作系统是如何对内存创建抽象以及如何管理内存的  

### 无存储器抽象
上古时期:每个程序都直接访问物理内存，同一时刻只有一个进程在执行
实现多进程的方法:

1. 交换机制:同一时间内存中只有一个程序,将程序保存到硬盘中,载入其他进程,时间片轮转
2. 无交换机制:保护建机制,存储分配给每个进程的内存块的保护键,通过教研psw码与保护键,判断某一进程是否是否越界.
> 缺陷：在将多个进程按照内存分片载入内存块之后,如果进程内的代码想要访问以0地址开始的内存地址时，就会出错，例如进程1载入到了0-16380内存位置,进程2载入到了16380-32764内存位置,进程2并不知道自己会被载入到高位,所以他的代码还是以0地址访问来写的。这样如果进程2如果要访问4地址，其实他要访问的是16384地址。
<strong>关键问题在于:两个程序都采用了绝对地址。
解决方法:静态重定位技术。在进程2被加载后,讲偏移量加到程序代码中每个地址上。
还特么是有问题的:MOV REGISTER1， 28 这个28怎么加,加载怎么判断这个28是地址还是计算值!还会导致加载速度变慢!好气！</strong>

### 一种存储器抽象:地址空间
物理内存裸露的危害:
* 如果用户进程能够访问每个内存地址,那么用户可能会破坏操作系统
* 难以实现多进程
需要解决的问题:
* 保护
* 重定位
解决方法:<strong>地址空间</strong>
> 就像进程的概念创在了一类抽象的CPU以运行程序一样,地址空间微程序创造了一种抽象的内存。

#### 实现方法
* 基址寄存器与界限寄存器
将每个进程的地址空间映射到物理内存的各个部分。
基址寄存器存储进程的在内存中的起始地址,界限寄存器存储进程在内存中的大小。
每次进程访问内存,取一条指令,读写一个数据字,CPU硬件会把地址发送到内存总先前，自动把基地址加到进程发出的地址值上,同时检查地址是否大于等于界限寄存器里的值。
> 1.基址寄存器与界限寄存器方法与静态重定位技术区别:静态重定位是通过修改载入代码的方式,实现了代码内地址的重定位,基址寄存器界限寄存器方法是通过修改CPU访问内存时的地址修改的方法来重定位。
> 2.<strong>基址寄存器与界限寄存器方法的缺陷</strong>:每次访问内存都会进行加法和比较运算,比较可以快速完成,但是加法由于进位传递时间的问题，没有特殊电路会显得很慢。

### 内存超载
如果载入了很多进程内存超载了怎么办:两种方法
1. 交换技术
2. 虚拟内存
#### 交换技术